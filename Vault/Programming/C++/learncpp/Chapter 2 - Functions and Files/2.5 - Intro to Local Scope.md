
# <u> Local Variables </u>
*Variables defined inside the body of a function are called **local variables**.*

```cpp
int add (int x, int y) {
	int z {x + y};
	return z;
}
```
> [!Danger] Function parameters are also considered local variables.

---
# <u> Local Variable Lifetime </u> 
*A variable definition such as `int x;` causes the variable to be instantiated when this statement is executed. Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.*

For example...
```cpp
int add(int x, int y) // x and y created and initialized here
{
	int z{ x + y};    // z created and initialized here
	return z;
}
```
> [!Danger] Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined. 
Lifetime is defined as the time between its creation and destruction. Creation and Destruction only happens at runtime, so lifetime is a runtime property.

Here's a more complicated example...
```cpp
#include <iostream>

void doSomething()
{
	std::cout << "Hello!\n";
}

int main()
{
	int x{ 0 };        //x's lifetime begins here.
	doSomething();     //x is still alive during this function call.
	return 0;          //x's lifetime ends here.
}
```

---

# <u> Local Scope (Block Scope) </u>
*An identifier’s **scope** determines where the identifier can be seen and used within the source code. When an identifier can be seen and used, we say it is **in scope**. When an identifier can not be seen, we can not use it, and we say it is **out of scope**. Scope is a compile-time property, and trying to use an identifier when it is not in scope will result in a compile error.

*The identifier of a local variable has local scope. An identifier with **local scope** (technically called **block scope**) is usable from the point of definition to the end of the innermost pair of curly braces containing the identifier (or for function parameters, at the end of the function). This ensures local variables cannot be used before the point of definition (even if the compiler opts to create them before then) or after they are destroyed. Local variables defined in one function are also not in scope in other functions that are called.*

Here's an example
```cpp
#include <iostream>

void doSomething() {
	std::cout << "Hello\n";
}

int main() {
	//x cannot be used here because it's not in scope yet.
	int x { 0 }; //x enters scope and can now be used within this function.
	doSomething();
	
	return 0;
} //x goes out of scope and can no longer be used.
```


> [!Danger] Out of Scope vs Going out of Scope
>An identifier is out of scope anywhere it cannot be accessed within the code. In the example above, the identifier `x` is in scope from its point of definition to the end of the `main` function. The identifier `x` is out of scope outside of that code region.
>
The term “going out of scope” is typically applied to objects rather than identifiers. We say an object goes out of scope at the end of the scope (the end curly brace) in which the object was instantiated. 

---
# <u> Another Example of Lifetime </u>
*Here’s a slightly more complex example. Remember, lifetime is a runtime property, and scope is a compile-time property, so although we are talking about both in the same program, they are enforced at different points.*

```cpp
#include <iostream>

int add(int x, int y) //x and y are created and enter scope here
{
	//x and y usable only within add()
	return x + y;
} //y and x go out of scope and are destroyed here.

int main()
{
	int a{ 5 }; // a is created, initialized, and enters scope here
	int b{ 6 }; // b is created, initialized, and enters scope here
	
	//a and b are only usable within main()
	
	std::cout << add(a, b) << '\n'; // calls add(5,6), where x=5, y=6
	return 0;
}// b and a go out of scope and are destroyed.
```
- Execution starts at the top of `main`.
- `main` variable `a` is created and given value `5`.
- `main` variable `b` is created and given value `6`.
- Function `add` is called with argument values `5` and `6`.
- `add` parameters `x` and `y` are created and initialized with values `5` and `6` respectively.
- The expression `x + y` is evaluated to produce the value `11`.
- `add` copies the value `11` back to caller `main`.
- `add` parameters `y` and `x` are destroyed.
- `main` prints `11` to the console.
- `main` returns `0` to the operating system.
- `main` variables `b` and `a` are destroyed.

> [!Danger] If function `add` were to be called twice, parameters `x` and `y` would be created and destroyed twice, once for each call.
> 

> [!Danger] A function parameter should be used when the caller will pass in the initialization value as an argument. A local variable should be used otherwise.

