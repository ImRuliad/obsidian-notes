# Heres is the first attempt at the solution

```python
class Solution:
	def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
		list_p = []
		list_q = []
		def dfs_p(p_root, list_p):
			if not p_root: return 0
			left = dfs_p(p_root.left, list_p)
			list_p.append(left)
			right = dfs_p(p_root.right, list_p)
			list_p.append(right)
	dfs_p(p, list_p)
	print(list_p)
```

# What’s going wrong in your code
- You never append the node’s **value**. You append `left` and `right`, which are the **return values of the recursive calls** (i.e., `None`), not the node values.
- You return `0` for a missing node; that collides with a real node whose value is `0`. You must distinguish structure explicitly.
- You only traverse `p` and never build/compare `q`.
- `isSameTree` must return a **bool**, but your function doesn’t return anything yet.

# Heres is the accepted solution
```python
class Solution:
	def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
		list_p = []
		list_q = []
		
		def dfs(root, val_list):
			if not root:    
				val_list.append(None)
				return
		val_list.append(root.val)
		left = dfs(root.left, val_list)
		right = dfs(root.right, val_list)
		
		dfs(p, list_p)
		dfs(q, list_q)
	return list_p == list_q
```
# Why does `return` work after appending `None`?
- That `return` is just an _early exit_ for the base case in the helper.
- When `node` is `None`, we **record a sentinel** (`None`) so the tree’s shape is preserved, and then we **exit that call**.
- Without the `return`, we’d fall through and try to access `node.val` or recurse on children of `None`, which would error.
- You could also write it without `return` using an `else`

# Why append `node.val` once, then recurse left and right?
Because each recursive call should be responsible for **writing exactly one thing**: the current node’s representation (its value, or a sentinel for `None`). Then it delegates the rest to its children.

That pattern is “preorder with nulls”:
-  Visit current → `out.append(node.val)`
-  Recurse left
-  Recurse right
This guarantees:
- Every real node contributes **exactly one** value to the list.
- Every missing child contributes **exactly one** `None` to the list.
- The order is consistent and unambiguous, so different shapes don’t collide.

# Why not, from the parent, “append left.value” then “append right.value”?
Three problems:
1. **AttributeError / Missing child**  
	- If `left` is `None`, `left.val` explodes. You’d need to check for `None` _every time_ and append a sentinel. That’s exactly what `encode(left, out)` already does.
2. **You’d either miss deeper nodes or double-count**
	- If you only append `left.val` and `right.val` at the parent and stop, you miss grandchildren/great-grandchildren entirely.
	- If you append child values **and** still recurse, you’ll append those child values **twice** (once in the parent, once in the child’s own call).
3. **Breaks the “one frame, one write” invariant**  
    - Keeping each frame responsible for its own output keeps the traversal clean and correct. Parents shouldn’t reach into child internals; they should just **call** the child and let it handle itself.