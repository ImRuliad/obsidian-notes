
> [!question] PROBLEM STATEMENT
> For two strings `s` and `t`, we say "`t` divides `s`" if and only if `s = t + t + t + ... + t + t` (i.e., `t` is concatenated with itself one or more times).
> Given two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`.
> 
> **Example 1:**
> **Input:** str1 = "ABCABC", str2 = "ABC"
> **Output:** "ABC"
> 
> **Example 2:**
> **Input:** str1 = "ABABAB", str2 = "ABAB"
> **Output:** "AB"
> 
> **Example 3:**
> **Input:** str1 = "LEET", str2 = "CODE"
> **Output:** ""

> [!info] Thought Process
> - if `str2 + str1` !=  `str1 + str2` then return ""
> - Iterate through str2 in reverse
> 	- check if len(str1) % len(prefix) == 0 and len(word2) % len(prefix) == 0
> -  if it does not
> 	- decrement by 1
> - if it does
> 	- check if prefix * len(word1) // len(prefix) == word1
> 	- check if prefix * len(word2) // len(prefix) == word2
> 	- if both are true return prefix
> 	- if either fails, decrement by 1
> 

## Brute Force Solution
```python
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if str2 + str1 != str1 + str2:  return ""
        size1, size2 = len(str1), len(str2)

        for index, letter in reversed(list(enumerate(str2))):
            prefix = str2[:index+1]
            size_p = len(prefix)
            if size1 % size_p == 0 and size2 % size_p == 0:
                divisor1 = prefix * (size1 // size_p)
                divisor2 = prefix * (size2 // size_p)
                if divisor1 == str1 and divisor2 == str2:
                    return prefix
```
